# Configuration for running Cortex in single-process mode.
# This should not be used in production.  It is only for getting started
# and development.

image:
  organization: neon-system-registry
  repository: cortexproject-cortex
  tag: v1.6.0
  pullPolicy: Always

serviceAccount:
  create: true
  name:
  annotations: {}

rbac:
  create: true
  pspEnabled: true

replicas: 1

cortexConfig:
  # Disable the requirement that every request to Cortex has a
  # X-Scope-OrgID header. `fake` will be substituted in instead.
  auth_enabled: false

  server:
    http_listen_port: 9009
    http_listen_address: 0.0.0.0
    grpc_listen_port: 9095
    grpc_listen_address: 0.0.0.0

    # Configure the server to allow messages up to 100MB.
    grpc_server_max_recv_msg_size: 104857600
    grpc_server_max_send_msg_size: 104857600
    grpc_server_max_concurrent_streams: 1000
    grpc_server_min_time_between_pings: 10s
    grpc_server_ping_without_stream_allowed: true

  distributor:
    shard_by_all_labels: true
    pool:
      health_check_ingesters: true

  ingester_client:
    grpc_client_config:
      # Configure the client to allow messages up to 100MB.
      max_recv_msg_size: 104857600
      max_send_msg_size: 104857600
      grpc_compression: gzip

  limits:
    max_series_per_metric: 0
    max_series_per_user: 0
    max_metadata_per_user: 0
    max_metadata_per_metric: 100
  blocks_storage:
    backend: s3
    tsdb:
      dir: /tmp/cortex/tsdb
    bucket_store:
      sync_dir: /tmp/cortex/tsdb-sync
    s3:
      bucket_name: cortex
      endpoint: neon-metrics-minio:9000
      access_key_id: ${ACCESS_KEY_ID}
      secret_access_key: ${SECRET_ACCESS_KEY}
      insecure: true

  ingester:
    lifecycler:
      # The address to advertise for this ingester. Will be autodiscovered by
      # looking up address on eth0 or en0; can be specified if this fails.
      address: 0.0.0.0

      # We want to start immediately and flush on shutdown.
      join_after: 0
      final_sleep: 0s
      num_tokens: 512

      # Use an in memory ring store, so we don't need to launch a Consul.
      ring:
        kvstore:
          store: etcd
          etcd:
            endpoints:
              - neon-metrics-etcd:2379
        replication_factor: 3
  storage:
    engine: blocks
  frontend_worker:
    match_max_concurrent: true
    frontend_address: 0.0.0.0:9095
  ruler:
    enable_api: true
    enable_sharding: false
    ring:
      kvstore:
        store: inmemory
    storage:
      type: local
      local:
        directory: /tmp/cortex/rules
  compactor:
    data_dir: /tmp/cortex/compactor
    sharding_ring:
      kvstore:
        store: inmemory
     



strategy:
  type: RollingUpdate
  rollingUpdate:
    maxSurge: 0
    maxUnavailable: 1

annotations: {}
nodeSelector:
  neonkube.io/monitor.metrics-internal: 'true'

affinity: {}

tolerations:
  - key: "neonkube.io/metrics"
    operator: Exists
    effect: NoSchedule

resources: {}

podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "http-metrics"
  readiness.status.sidecar.istio.io/applicationPorts: '9009,9095'

podLabels: {}

terminationGracePeriodSeconds: 2400

extraVolumes: {}

env:
  - name: POD_IP
    valueFrom:
      fieldRef:
        fieldPath: status.podIP
  - name: ACCESS_KEY_ID
    valueFrom:
      secretKeyRef:
        name: neon-metrics-minio
        key: accesskey
  - name: SECRET_ACCESS_KEY
    valueFrom:
      secretKeyRef:
        name: neon-metrics-minio
        key: secretkey

securityContext: {}

initContainers: []

startupProbe:
  exec:
    command:
    - "wget"
    - "-q"
    - "--spider"
    - "http://localhost:9009/ready"
  failureThreshold: 30
  periodSeconds: 10

livenessProbe:
  exec:
    command:
    - "wget"
    - "-q"
    - "--spider"
    - "http://localhost:9009/ready"
  initialDelaySeconds: 45
  periodSeconds: 3
readinessProbe:
  exec:
    command:
    - "wget"
    - "-q"
    - "--spider"
    - "http://localhost:9009/ready"
  initialDelaySeconds: 45
  periodSeconds: 3